\newpage
\section{Gstreamer}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Installing}

Use a package manager for your system – apt (Debian/Ubuntu), yum (Fedora/Centos) or homebrew (Mac).
\\


On Ubuntu 14-16 it comes pre-installed on the Desktop versions. If you don’t have it, you can try:
\begin{verbatim}sudo apt update && apt install -y gstreamer1.0-tools gstreamer1.0-plugins-base 
gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-
ugly gstreamer1.0-libav python-gst-1.0\end{verbatim}


\textbf{Elements}\\
The graph or chain formed with gstreamer is made of plugins. The graph (chain) begins with one or more \textbf{src} (source) plugins and ends with one or more \textbf{sink} (output) plugins. Here are some src and sink plugins:
\\

\textbf{ 1) I/O elements}\\

\textbf{ Input or SRC elements:}\\
\begin{itemize}
\item v4l2src – stream from a camera device on a linux system, e.g. device=/dev/video0;
\item fdsrc – use in conjunction with unix pipes, uses as input the output of other programs such as raspicam on a Raspberry Pi;
\item audiotestsrc – used to do test streams with audio;
\item videotestsrc – used to do test streams with video, you may specify a pattern=<num>;
\item fakesrc – another option for testing by feeding in an empty stream;
\item filesrc – stream from a file, specifiy location=<filepath>;
\item udpsrc – stream from a UDP stream, specify port=<number>;
\item tcpclientsrc – stream from a TCP (HTTP) stream, specify port=<number>;
\item rtmpsrc – stream from RTMP stream, specify port=<number>;
\item ximagesrc – capture screen.
\end{itemize}


\textbf{Output or SINK elements:}\\
\begin{itemize}
\item filesink – save stream to a file, specify location=<filepath>;
\item  audoaudiosink – play audio on an automatically detected device;
\item   autovideosink – play video on an automatically detected display utility and device;
\item   fakesink – do not play stream, just finish;
\item  udpsink – stream result over UDP, specify host=<IP of the target server> and port=<number>;
\item   multiudpsink
\item  tcpserversink- stream result over TCP (HTTP), specify host=<IP of the target server> and port=<number>;
\item rtmpsink- stream result over RTMP, specify host=<IP of the target server> and port=<number>.
\end{itemize}


\textbf{2) En/Decoding elements:}\\
Encoding a raw data stream and decoding encoded data into raw data is a big part of using gstreamer and dealing with media in general. Audio data can be encoded to various formats such as MP3, AAC, Vorbis and Opus. Video can be encoded among others as JPEG 2000, H.264, H.265, MPEG-2, VP8, VP9 and Theora. Gstreamer offers the possibilities to encode/decode in these formats through is bundle of plugins. These plugin bundles are the base, good, bad and ugly plugins.
\\


\textbf{Audio}\\
\begin{itemize}
\item mp3 – lamemp3enc, avenc\_mp3 | mad, mpg123audiodec, avdec\_mp3; 
\item  aac – voaccenc, faac, avenc\_aac | faad, aacparse, avdec\_aac;
\item  vorbis – vorbisenc | vorbisdec, vorbisparse;
\item  opus – opusenc, avenc\_opus | opusdec, avdec\_opus.
\end{itemize}


\textbf{Video}\\
\begin{itemize}
\item h.264 – x264enc, avh264\_enc |  h264parse, mpeg4videoparse, avdec\_h264;
\item mpeg2 -mpeg2enc, avenc\_mpeg2video | mpeg2dec, avdec\_mpeg2video;
\item jpeg2000 – no inter-frame coding, low latency; avenc\_jpeg2000 | avdec\_jpeg2000;
\item vp8 – vp8enc, avenc\_vp8 | vp8dec, avdec\_vp8;
\item vp9 – vp9enc, avenc\_vp9 | vp9dec, avdec\_vp9;
\item theora -theoraenc | theoradec, theoraparse.
\end{itemize}


\textbf{3) Capabilities or ‘caps’ elements}\\
Capabilities (short: caps) describe the type of data that is streamed between two pads (elements), or the one that a pad (template) supports. Capsfilters or \textbf{caps} do not modify data as such, but can enforce limitations on the data format. They ensure compatibility between elements. If for example a media stream is available in several formats, they can specify just one which is understandable by the next element in the pipeline. Capabilities can be very complex and specify all types of characteristics although that is often not required. Most often we should specify the type of encoding of the stream we receive or send.
\\
Examples:
\\
(1) Specifies the video as being raw (without encoding) and makes it have a specific width and height:
\begin{verbatim}
! video/x-raw, width=640, height=480 !
\end{verbatim}
(2) Specifies that the video is composed of RTP packages encoded as VP8:
\begin{verbatim}
! application/x-rtp, encoding-name=VP8 !
\end{verbatim}

\textbf{4) Other elements}\\
\begin{itemize}

\item  \textbf{Muxers/Demuxers} – These elements encapsulate (pair) video and audio in a common container. Common formats are mp4, webm, ogg, mov.
E.g.:  mp4mux/qtdemux, webmmux/matroskademux.

\item    \textbf{Payers/Depayers} – These elements prepare (payload) data prior and after it is transported over the Internet.
E.g.: rptvp8pay/rtpvp8depay,  rtph264/rtph264depay gdppay/gdpdepay.

\item    \textbf{Converters} – These elements perform data manipulations like rotation, color change, modulation and cropping.
E.g.: audioconvert, audioresample, videoconvert, videoscale.

\item    \textbf{Pipeline} – These elements are used in constructing more complex pipelines.
E.g.: tee, queue2.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Commands}
\textbf{1) Video test source to screen}
\begin{verbatim}
    gst-launch-1.0 videotestsrc pattern=1 ! videoconvert ! autovideosink
\end{verbatim}

\textbf{2) Audio test source to speakers}
\begin{verbatim}
   gst-launch-1.0 audiotestsrc ! audioconvert ! autoaudiosink
\end{verbatim}

\textbf{3) Audio test source to nothing (fake), but still a valid pipeline}
\begin{verbatim}
   gst-launch-1.0 audiotestsrc ! audioconvert ! fakesink
\end{verbatim}

\textbf{4) Video broadcast over TCP/HTTP}\\\\
\textbf{Send via:}
\begin{verbatim}
    gst-launch-1.0 videotestsrc horizontal-speed=5  ! vp8enc ! gdppay !
    tcpserversink host=127.0.0.1 port=5200
\end{verbatim}\\\\
\textbf{Receive via:}
\begin{verbatim}
    gst-launch-1.0 -v tcpclientsrc port=5200 ! gdpdepay ! vp8dec !
    videoconvert ! autovideosink
\end{verbatim}


\textbf{5) Video broadcast over RTP (via UDP) from a camera}\\\\
\textbf{Send via:}
\begin{verbatim}
    gst-launch-1.0 v4l2src ! \
	videoconvert ! video/x-raw, width=640,height=480 ! \
	omxh264enc ! \
    rtph264pay pt=96 config-interval=1 ! \
    udpsink host=192.168.2.106 port =8554
\end{verbatim}\\\\
\textbf{Receive via:}
\begin{verbatim}
    gst-launch-1.0 udpsrc port=8554 \
	caps="application/x-					  rtp,media=video,clockrate=90000,payload=96,encoding-name=H264" ! \
	rtph264depay ! avdec_h264 ! autovideosink
\end{verbatim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
