\newpage
\section{Gstreamer}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Installing}
Mittels Paketmanager APT (Debian/Ubuntu), yum (Fedora/Centos) or homebrew (Mac) 
fehlende Pakete installieren, am Beispiel Ubuntu (Rapian Debian):
\begin{verbatim}
sudo apt update && apt install -y gstreamer1.0-tools gstreamer1.0-plugins-base 
gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly 
gstreamer1.0-libav python-gst-1.0
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{I/O elements}
Ein Gstreamer Befehl ist aus einer Kette oder Graph von Plugins aufgebaut. Die Verkettung der Befehle startet mit ein oder mehreren \textbf{src} Plugins und endet mit einem oder mehreren \textbf{sink} Plugins. Es folgt eine List mit src und sink Plugins.\\

\textbf{Eingangs oder SRC Elemente}
\begin{itemize}
\item v4l2src – stream from a camera device on a linux system, e.g. device=/dev/video0;
\item fdsrc – use in conjunction with unix pipes, uses as input the output of other programs such as raspicam on a Raspberry Pi;
\item audiotestsrc – used to do test streams with audio;
\item videotestsrc – used to do test streams with video, you may specify a pattern=<num>;
\item fakesrc – another option for testing by feeding in an empty stream;
\item filesrc – stream from a file, specifiy location=<filepath>;
\item udpsrc – stream from a UDP stream, specify port=<number>;
\item tcpclientsrc – stream from a TCP (HTTP) stream, specify port=<number>;
\item rtmpsrc – stream from RTMP stream, specify port=<number>;
\item ximagesrc – capture screen.
\end{itemize}

\textbf{Ausgabe oder SINK Elemente}
\begin{itemize}
\item filesink – save stream to a file, specify location=<filepath>;
\item  audoaudiosink – play audio on an automatically detected device;
\item   autovideosink – play video on an automatically detected display utility and device;
\item   fakesink – do not play stream, just finish;
\item  udpsink – stream result over UDP, specify host=<IP of the target server> and port=<number>;
\item   multiudpsink
\item  tcpserversink- stream result over TCP (HTTP), specify host=<IP of the target server> and port=<number>;
\item rtmpsink- stream result over RTMP, specify host=<IP of the target server> and port=<number>.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{ En/Decoding elements}
Encoding a raw data stream and decoding encoded data into raw data is a big part of using gstreamer and dealing with media in general. Audio data can be encoded to various formats such as MP3, AAC, Vorbis and Opus. Video can be encoded among others as JPEG 2000, H.264, H.265, MPEG-2, VP8, VP9 and Theora. Gstreamer offers the possibilities to encode/decode in these formats through is bundle of plugins. These plugin bundles are the base, good, bad and ugly plugins.
\\

\textbf{Audio}
\begin{itemize}
\item mp3 – lamemp3enc, avenc\_mp3 | mad, mpg123audiodec, avdec\_mp3; 
\item  aac – voaccenc, faac, avenc\_aac | faad, aacparse, avdec\_aac;
\item  vorbis – vorbisenc | vorbisdec, vorbisparse;
\item  opus – opusenc, avenc\_opus | opusdec, avdec\_opus.
\end{itemize}

\textbf{Video}
\begin{itemize}
\item h.264 – x264enc, avh264\_enc |  h264parse, mpeg4videoparse, avdec\_h264;
\item mpeg2 -mpeg2enc, avenc\_mpeg2video | mpeg2dec, avdec\_mpeg2video;
\item jpeg2000 – no inter-frame coding, low latency; avenc\_jpeg2000 | avdec\_jpeg2000;
\item vp8 – vp8enc, avenc\_vp8 | vp8dec, avdec\_vp8;
\item vp9 – vp9enc, avenc\_vp9 | vp9dec, avdec\_vp9;
\item theora -theoraenc | theoradec, theoraparse.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mögichkeiten oder ‘caps’ Elemente}
Capabilities (short: caps) describe the type of data that is streamed between two pads (elements), or the one that a pad (template) supports. Capsfilters or \textbf{caps} do not modify data as such, but can enforce limitations on the data format. They ensure compatibility between elements. If for example a media stream is available in several formats, they can specify just one which is understandable by the next element in the pipeline. Capabilities can be very complex and specify all types of characteristics although that is often not required. Most often we should specify the type of encoding of the stream we receive or send.\\

Beispiele\\
Legt kein Encoding für das Video fest \textbf{RAW} und bestimmt die Breite x Höhe einer Framegröße:
\begin{verbatim}
  ! video/x-raw, width=640, height=480 !
\end{verbatim}
Legt für das Video den Pakettyp auf RTP und das Encoding auf VP8 fest.
\begin{verbatim}
  ! application/x-rtp, encoding-name=VP8 !
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Other elements}
\begin{itemize}
\item \textbf{Muxers/Demuxers} – These elements encapsulate (pair) video and audio in a common container. Common formats are mp4, webm, ogg, mov.
E.g.:  mp4mux/qtdemux, webmmux/matroskademux.
\item \textbf{Payers/Depayers} – These elements prepare (payload) data prior and after it is transported over the Internet.
E.g.: rptvp8pay/rtpvp8depay,  rtph264/rtph264depay gdppay/gdpdepay.
\item \textbf{Converters} – These elements perform data manipulations like rotation, color change, modulation and cropping.
E.g.: audioconvert, audioresample, videoconvert, videoscale.
\item \textbf{Pipeline} – These elements are used in constructing more complex pipelines. E.g.: tee, queue2.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Testkommandos für Audio \& Video}
\textbf{Video Test Source zum Display}
\begin{verbatim}
  gst-launch-1.0 videotestsrc pattern=1 ! videoconvert ! autovideosink
\end{verbatim}

\textbf{Audio Test Source zum Lautsprecher}
\begin{verbatim}
  gst-launch-1.0 audiotestsrc ! audioconvert ! autoaudiosink
\end{verbatim}

\textbf{Audio Test Quelle zu Fake Sink, aber trotzdem vollständige Pipeline}
\begin{verbatim}
  gst-launch-1.0 audiotestsrc ! audioconvert ! fakesink
\end{verbatim}

\textbf{Video Test broadcast over TCP/HTTP}
\begin{verbatim}
Sender
  gst-launch-1.0 videotestsrc horizontal-speed=5  ! vp8enc ! gdppay ! \
    tcpserversink host=127.0.0.1 port=5200
Receiver
  gst-launch-1.0 -v tcpclientsrc port=5200 ! gdpdepay ! vp8dec ! \
    videoconvert ! autovideosink
\end{verbatim}

\textbf{Video Broadcast über RTP (via UDP) von Webcam}
\begin{verbatim}
Sender
  gst-launch-1.0 v4l2src ! videoconvert ! video/x-raw, width=640,height=480 ! \
    omxh264enc ! rtph264pay pt=96 config-interval=1 ! \
    udpsink host=192.168.2.106 port =8554
Receiver
  gst-launch-1.0 udpsrc port=8554 caps="application/x-rtp,media=video,\
    clockrate=90000,payload=96,encoding-name=H264" ! \
    rtph264depay ! avdec_h264 ! autovideosink
\end{verbatim}

\textbf{Video mit synthetischem Audio}
\begin{verbatim}
Reciever
  gst-launch-1.0 udpsrc port=5001 ! application/x-rtp, clock-rate=44100, payload=97 ! 
    rtpL16depay ! audioconvert ! alsasink sync=false udpsrc port=5000 
    caps="application/x-rtp,media=video,payload=96,encoding-name=H264" ! rtph264depay !     
    avdec_h264 ! autovideosink
Sender:
  gst-launch-1.0 -v audiotestsrc ! audioconvert ! \
    audio/x-raw,channels=1,depth=16,width=16,rate=44100 ! rtpL16pay pt=97 ! \
    udpsink host=192.168.178.29 port=5001 v4l2src ! videoconvert ! \
    video/x-raw, width=640,height=480 ! omxh264enc ! \
    rtph264pay pt=96 config-interval=1 ! \
    udpsink host=192.168.178.29 port=5000
\end{verbatim}

\textbf{Video and Audio over RTP (via UDP) from Webcam}
\begin{verbatim}
Sender
  gst-launch-1.0 -v alsasrc device=plughw:CARD=StudioTM,DEV=0 ! \
    audioconvert ! audio/x-raw,channels=1,depth=16,width=16,rate=44100 ! \
    rtpL16pay pt=97 ! udpsink host=192.168.178.29 port=5001 v4l2src ! \
    videoconvert ! video/x-raw, width=640,height=480 ! omxh264enc ! \
    rtph264pay pt=96 config-interval=1 ! udpsink host=192.168.178.29 port=5000
Receiver
  gst-launch-1.0 udpsrc port=5001 ! application/x-rtp, clock-rate=44100,\
    payload=97 ! rtpL16depay ! audioconvert ! alsasink sync=false udpsrc \
    port=5000 caps="application/x-rtp,media=video,payload=96,encoding-name=H264" ! \
    rtph264depay ! avdec_h264 ! autovideosink
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{gstreamer C Programme \& Tutorials selbst kompilieren}

Wenn Fehler beim Compilieren eines gstream Testprogramms auftreten, z.B.
\begin{verbatim}
  Package gstreamer-1.0 was not found in the pkg-config search path.
  Perhaps you should add the directory containing `gstreamer-1.0.pc'
  to the PKG_CONFIG_PATH environment variable
  No package 'gstreamer-1.0' found
  playback-tutorial-6.c:1:10: fatal error: gst/gst.h: No such file or directory
\end{verbatim}

gstreamer-1.0 ist der folgenden lib enthalten:
\begin{verbatim}
  sudo apt install libgstreamer1.0-dev
\end{verbatim}

\textbf{Compiler Befehl für Beispiel 6}\\
gcc playback-tutorial-6.c -o playback-tutorial-6 `pkg-config --cflags --libs gstreamer-1.0`

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
